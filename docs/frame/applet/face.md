---
toc: menu
---

# 小程序宝典

## 1.双线程模型

### 1）为什么小程序要使用双线程模型，不直接用浏览器的线程模型

- 与 Web 网站相比，以微信为宿主的小程序更需要考虑安全、性能等因素：

  - 因为要考虑小程序不会对微信产生安全隐患

  - 要尽量达到接近原生应用的用户体验

### 2）浏览器并不是单线程而是多进程的

- 浏览器内部架构很复杂，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式

  - 以 Chrome 浏览器为例，Chrome 开启了多个进程，包括浏览器进程、网络进程、GPU 进程等，这些都是通用的进程。注意到没有，图里有两个标签页进程，Chrome 为每个标签页开启了一个独立的渲染进程（ Renderer Process ），每个进程之间的资源（ CPU、内存等）和行为（ UI、逻辑等）互不共享，所以即便某个标签页崩溃了也不会影响其他标签页

  - 而在每个标签页进程中，浏览器会把不同的工作交给对应的线程，比如 GUI 渲染线程负责把 HTML 渲染成可视化的 UI；JavaScript 引擎线程负责解析和运行 JavaScript 代码逻辑；定时触发器线程负责处理 setTimeout/setInterval 定时器等

  - setTimeout/setInterval 并不是 JavaScript 语言的一部分，而是运行时（最初是浏览器，后来 Node.js 也提供了支持）提供的能力

### 3）为什么 GUI 渲染线程与 JavaScript 引擎线程是互斥的

- JavaScript 代码有修改 DOM 的权限

- 当 JavaScript 代码被执行时，GUI 渲染线程会被挂起，等待 JavaScript 引擎线程空闲时再被执行，以免在渲染期间被 JavaScript 重复地修改 DOM 造成不必要的渲染压力

- 采用互斥的模式等待 JavaScript 代码执行完毕后，可以保证渲染是最终的执行结果

### 4）Web Worker

- HTML5 引入了 Web Worker，提供多线程执行 JavaScript 代码的能力，但是与其他编程语言不同的是，Worker 线程与主线程并不是扁平的，而是一种主从（ Master-Slave）多线程模型

- Worker 内的 JavaScript 代码无法获取 Window 和 Document 对象，也就不能操作 DOM，可以将其理解为线程安全的，由于 Worker 的线程安全特性，Worker 内的代码运行过程中不会阻塞外层的 GUI 渲染线程，两者可以并行

### 5）安全高效的小程序双线程模型

- 限制 UI 组件类型，只允许声明指定的几个组件

- 保证逻辑线程安全，不允许直接操作 UI 组件

- 能够在线更新，不依赖微信

- 性能需尽量提升，保证用户体验

### 6）渲染线程和逻辑线程

![image](images/frame/41.png)

- 渲染线程使用 Webview 进行 UI 的渲染呈现。Webview 是一个完整的类浏览器运行环境，本身具备运行 JavaScript 的能力，但是小程序并不是将逻辑脚本放到 Webview 中运行，而是将逻辑层独立为一个与 Webview 平行的线程，使用客户端提供的 JavaScript 引擎运行代码，iOS 的 JavaScriptCore、安卓是腾讯 X5 内核提供的 JsCore 环境以及 IDE 工具的 nwjs

- 逻辑线程是一个只能够运行 JavaScript 的沙箱环境，不提供 DOM 操作相关的 API，所以不能直接操作 UI，只能够通过 setData 更新数据的方式异步更新 UI

- 逻辑与渲染分离的线程分工模式一方面能够保证运行在逻辑线程沙箱内的 JavaScript 代码是线程安全的，另一方面由于渲染线程的计算量非常小从而保证了对用户交互行为的快速响应，提高了用户体验

## 2.借助微信开发者工具提升小程序性能

### 1）避免过大的 WXML 节点数目

- DOM 树的结构越复杂，渲染的管线就会越慢

- 节点数目过多或者层次太深，那么在调用 setData 更新 UI 时就会给 CPU 和内存过多的压力，进而可能造成小程序的假死

### 2）避免执行脚本的耗时过长

- 但是逻辑线程执行 JavaScript 代码时仍旧是单线程的，通过任务队列管理代码的有序执行。如果某一段 JavaScript 代码逻辑占时太长，造成任务队列过长，最终会影响小程序在响应用户交互行为上的长延时或卡顿

### 3）避免首屏时间太长

- 1.代码优化：

  - 降低 WXML 的结构复杂度，比如节点个数和深度

  - 降低首次渲染的数据规模，首次渲染只包含核心数据，非核心数据的渲染可推迟到首屏渲染完成之后进行

  - 从设计和交互的角度出发，在实际内容被渲染之前展示友好的 loading 效果

- 2.网络优化：

  - 减少网络请求所携带的数据体积，这是最直观的网络优化方案

  - 提高服务器处理网络请求的速度

### 4）避免渲染界面的耗时过长的情况

- 避免 setData 的调用过于频繁：任务数量过多

- 避免 setData 的数据量太大：单个任务过重

### 5）对网络请求做必要的缓存以避免多余的请求

### 6）避免短时间内发起太多的图片请求

- 目前前端和小程序领域中使用的仍旧是 HTTP 1.1 协议，一个 TCP 链接同时只能处理一个 HTTP 请求，在前一个请求得到服务器的响应之后才会发起第二个请求，如果同一时间的 HTTP 请求太多就会产生排队

- 浏览器为了应对这种问题，提供了建立多个 TCP 连接以实现并行发送 HTTP 请求的目的，目前市面上的浏览器最多支持同时建立 4~8 个 TCP 连接。也就是说，最多可以同时处理 4~8 个 HTTP 请求。如果同一时刻需要发送的 HTTP 请求数量远大于这个数字，那么还是会产生排队

## 3.使用 Webpack 提升小程序研发效率

- 管理第三方 npm 模块

- 使用 TypeScript 编写源码

- 使用预处理器编写模块化的样式

- 使用 lint 工具统一源码规范

- 图片压缩

- 多环境支持
