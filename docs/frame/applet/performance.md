---
toc: menu
---

# 小程序性能优化

## 1.启动加载性能

### 1）首次加载

- 首次加载时，微信会在背后完成几项工作：

  - 下载小程序代码包

  - 加载小程序代码包

  - 初始化小程序首页

- 下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包

### 2）加载顺序

- 资源准备（代码包下载）

- 业务代码的注入以及落地页首次渲染

- 落地页数据请求时的 loading 态

### 3）控制包大小

- 勾选开发者工具中“上传代码时，压缩代码”选项

- 及时清理无用的代码和资源文件（包括无用的日志代码）

- 减少资源包中的图片等资源的数量和大小（理论上除了小 icon，其他图片资源从网络下载），图片资源压缩率有限

### 4）采用分包加载机制

- 将用户访问率高的页面放在主包里

- 将访问率低的页面放入子包里，按需加载

- 独立分包不依赖主包加载，其他分包，需要先下载主包

- 单个分包不宜过大

- 单个分包/主包大小不能超过 2M，所有分包大小不超过 20M

### 5）采用分包预加载技术

- 用户点击到子包时，需要先下载子包，会有明显的卡顿

- 采用预加载，用户进入到某个页面后，提前下载分包

- 可以在指定网络下预下载，可选值为：

  - all: 不限网络

  - wifi: 仅 wifi 下预下载

### 6）首屏加载优化

**1.提前请求**

- 可以在 onload 中进行异步请求

**2.利用缓存**

- 利用 storage API,对变动频率低的数据进行缓存

**3.避免白屏**

- 可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页）

- 使用骨架屏

**4.及时反馈**

- 请求时，使用 loading 加载，避免页面无响应

## 2.渲染性能

### 1）避免使用不当 setData

- 在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层

- 同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据

**1.不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用**

- 每次 setData 的调用都是一次进程间的通信过程，通信开销与 setData 的数据量正相关

- setData 会引发视图层页面内容的更新，一定时间内会阻塞用户操作

- setData 是小程序开发使用最频繁，也是最容易引发性能问题的

**2.数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用 setData 来设置这些数据**

- 可以使用 setData 的特殊 key 实现局部更新

```js
this.setData({
  'userInfo.name': 'newName',
});

this.setData({
  list[index] = newList[index]
});
```

**3.与界面渲染无关的数据最好不要设置在 data 中，可以考虑设置在 page 对象的其他字段下**

**4.切勿在后台页面进行 setData**

- 多个 webview 是共享一个 js 进程；后台的 setData 操作会抢占前台页面的渲染资源

### 2）用户事件使用不当

**1.去掉不必要的事件绑定（WXML 中的 bind 和 catch），从而减少通信的数据量和次数**

**2.事件绑定时需要传输 target 和 currentTarget 的 dataset，因而不要在节点的 data 前缀属性中放置过大的数据**

### 3）视图层渲染原理

**1.首次渲染**

- 初始渲染时，将初始数据套用在对应的 WXML 片段上生成节点树。节点树也就是在开发者工具 WXML 面板中看到的页面树结构，它包含页面内所有组件节点的名称、属性值和事件回调函数等信息。最后根据节点树包含的各个节点，在界面上依次创建出各个组件

**2.重渲染**

- 每次应用 setData 数据时，都会执行重渲染来更新界面

- 每次重渲染时，将 data 和 setData 数据套用在 WXML 片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将 setData 数据合并到 data 中，并用新节点树替换旧节点树，用于下一次重渲染

### 4）使用自定义组件

- 自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响

  - 比如定时组件：定时组件的更新并不会影响页面上其他元素的更新

- 各个组件也将具有各自独立的逻辑空间

  - 每个组件都分别拥有自己的独立的数据、setData 调用

### 5）避免不当的使用 onPageScroll

- 每一次事件监听都是一次视图到逻辑的通信过程，所以只在必要的时候监听 pageSrcoll

## 3.总结

### 1）小程序启动加载性能

- 控制代码包的大小

- 分包加载

- 首屏体验（预请求，利用缓存，避免白屏，及时反馈

### 2）小程序渲染性能

- 避免不当的使用 setData

- 合理利用事件通信

- 避免不当的使用 onPageScroll

- 优化视图节点

- 使用自定义组件

## 4.图片

- 压缩，推荐 tinypng.com/

- Image 组件支持通过配置 lazy-load 参数来实现懒加载懒加载

- 利用 cdn 服务商（阿里云 OSS）提供的能力获取适当的图片,支持格式转换、质量变换、尺寸处理

- 使用 webp 格式的图片

## 5.多线程 Worker

- 一些异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到小程序主线程

- Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法

- 双方使用 Worker.postMessage() 来发送数据

- Worker.onMessage() 来接收数据

- 传输的数据并不是直接共享，而是被复制的

```js
const worker = wx.createWorker('workers/request/index.js'); // 文件名指定 worker 的入口文件路径，绝对路径

worker.postMessage({
  msg: 'hello worker',
});

worker.onMessage(function (res) {
  console.log(res);
});
```
