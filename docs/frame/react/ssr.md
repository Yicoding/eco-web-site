---
toc: menu
---

# react-ssr

## 1.CSR

### 1）定义

- `Client Side Rendering`：`客户端渲染`

- 是目前 `Web` 应用中`主流`的渲染模式，由 Server 端返回初始 `HTML` 内容，然后再由 `JS` 去`异步加载数据`，`再完成`页面的渲染

- `客户端渲染`模式中`最流行`的开发模式是 `SPA（单页应用）`

### 2）SPA 优点

- 1.页面之间的`跳转`不会刷新整个页面，而是`局部刷新`，`体验`上有了很大的`提升`

- 2.单页应用中，只有`首次`进入或者`刷新`的时候`才`会`请求`服务器，`只需加载一次` js css `资源`，页面的`路由`维护`在客户端`，页面间的`跳转`就是`切换`相关的`组件`，所以`切换速度`很`快`

- 3.`数据渲染`都在`客户端完成`，服务器只需要提供一个返回数据的接口,大大`降低`了`服务器的压力`

- 也叫 `web app`，是为了突出这种`体验`很`像`是 `Native App`

### 3）缺点

- 1.`对 SEO 不友好`

- 2.页面`首次加载`可能有`较长的白屏时间`

## 2.SSR

### 1）定义

- `Server Side Rendering`：`服务端渲染`

- 将`渲染`的工作放`在服务端进行`

- 在 `Ajax` 出现`之前`全部都是这种方式，由`服务端返回`给浏览器`完整`的 `html` 内容
  - `浏览器`得到完整的结构后就`可直接`进行 DOM 的解析、构建、加载资源及后续的`渲染`

### 2）优点

- 1.页面（html）直出的方式可以让页面`首屏较快`的`展现`给用户

- 2.对搜索引擎比较友好，爬虫可以方便的找到页面的内容，非常`有利于SEO`

### 3）缺点

- 1.`所有页面`的`加载`都需要向`服务器`请求完整的页面内容和资源，`访问量较大`的时候会`对服务器造成一定的压力`

- 2.页面之间`频繁刷新跳转`的`体验`并`不是很友好`

## 3.SSR VS CSR(SPA)

### 1）首屏加载

- `SSR` 比 CSR `更快`

- 在`弱网环境`下会体现的`更`加`明显`

### 2）体验

- `SPA（客户端渲染）` 方式比 SSR (服务端渲染) 模式在`体验和性能`上有了`很大`的`提升`

### 3）SEO

- `SAP 对 SEO 不够友好`：
  - 有些网站的`流量来源`主要还是`靠搜索引擎`，SEO 效果还是很重要的
  - `SPA` 模式页面`数据非直出`，搜索引擎爬虫`拿不到`具体的`数据`
  - `无法`对网站的内容进行`识别和分类`，得不到网站的关键词和描述信息
  - `无法`进行`排名`，甚至`不会被收录`
  - 结果就是在`搜索引擎`里`搜不到`你的`站点`

### 4）首次白屏等待

- SPA，第一次打开页面得到的是一个 html 框架，不包含内容
- 数据的渲染需要等待页面 js css 资源加载完成,且执行时再发起异步数据请求
- 然后等数据返回后，再进行渲染
- 渲染完成后用户才能看到最终的页面

## 4.React SSR

### 1）解决问题

- 1.`SPA` 模式，虽然体验提升，也降低了服务端的压力，但是仍有缺陷：

  - 1.`SEO 不友好`

  - 2.`首次白屏等待`

- 2.`SSR` 对 SEO 友好、会直接返回完整的 html 数据，但是却没有 SPA 的优势

### 2）SSR + SPA 完美结合

- 两种技术和体验的结合：

  - 1.`第一次`打开页面是`服务端渲染`

  - 2.`后续`交互是 `SPA` 的效果和体验

  - 3.`解决 SEO` 问题

  - 4.保持页面切换的效率

  - 5.`服务器压力`比传统的 ssr 也相对`小`

### 3）完整的开发框架

- `nuxt.js`
- `next.js`

## 5.虚拟 dom

- 组件`可以在服务端渲染`的`根本原因`就是`虚拟 DOM`

- `jsx` 只是一个`抽象语法糖`，看上去是写 html，实际`写`的是`对象`

- `虚拟 DOM` 渲染时用于`提高渲染性能`，以`最小的代价`来`更新视图`的作用外

  - 为组件的`跨平台渲染`提供可能

- `虚拟 DOM` 本身 就是一个`内存中的对象`，通过`对象的属性`来描述要`渲染`的具体是什么`元素`以及`内容`

**html**

```js
<ul id="list">
  <li class="item">1</li>
  <li class="item">2</li>
  <li class="item">3</li>
</ul>
```

**=> 转换为虚拟 dom**

```js
const tree = {
  tag: 'ul', // 节点标签名
  props: {
    // DOM的属性，用一个对象存储键值对
    id: 'list',
  },
  children: [
    // 该节点的子节点
    { tag: 'li', props: { class: 'item' }, children: ['1'] },
    { tag: 'li', props: { class: 'item' }, children: ['2'] },
    { tag: 'li', props: { class: 'item' }, children: ['3'] },
  ],
};
```

- 可以`把`这个`对象转换`想要的表现形式，比如 html 格式，而这个 html 就是要`直出的内容`

- `react` 供了`内置方法`来`支持服务端渲染`

## 6.同构

- 指前后端公用一套代码：

  - 组件可以在服务端渲染也可以在客户端渲染，但都是同一个组件

- 打造同构应用的条件：双端使用同一种语言 - javascript

  - 前端 react，服务端使用 node

- `浏览器`接管页面后的进一步渲染（交互、事件）过程中，会`判断`已有的 DOM 结构和浏览器渲染出的结构`是否相同`，若`相同`，则`不重复渲染`，`只`需要`绑定事件`即可
  - react 提供的双端节点对比功能，是为了最大限度的提高页面的渲染效率，尽可能的重用服务端给出的 html 结构

## 7.打造同构应用

- 同构的最大优点是双端可以公用一套代码，因为涉及到服务端，所以复杂性大大增加

- 双端也不是完全能公用一套代码，还需要做很多差异化的处理。不只是代码层面的，还会涉及到架构和工程化

- 需要一个轮子，这个轮子本身已经完备了双端的差异处理，开发者只需要关心自身业务逻辑，开发中无差异化
  - React SSR 应用开发骨架

## 8.双端对比机制

### 1）ReactDOMServer

- 可以在服务端渲染组件 - 得到组件的 html 字符串

**1.renderToString()**

```js
ReactDOMServer.renderToString(element);
```

- 把一个 `React` 组件`渲染`为原始的` HTML`

- 用这个方法在服务端生成 HTML 字符串，然后将该字符串返回给浏览器端，完成页面内容的初始化，同时让搜索引擎可以抓取你的页面来达到优化 SEO 的目的

- 在 `react 16 前`该方法生成的 html 内容的每一个 `DOM` 节点都有一个 `data-react-id` 属性，根节点会有一个 `data-react-checksum` 属性

  - 组件在服务端渲染后，在浏览器端还会渲染一次，来完成组件的交互等逻辑
  - 渲染时，react 在浏览器端会计算出组件的 data-react-checksum 属性值，如果发现和服务端计算的值一致，则不会进行客户端渲染。所以 data-react-checksum 属性的作用是为了完成组件的双端对比
  - 如果两个组件的 props 和 DOM 结构是相同的，那么计算出的该属性值就是一致的
  - 当双端渲染的组件的 props 和 DOM 结构一致时，那么该组件只会渲染一次，客户端会采用服务端渲染的结果，仅作事件绑定等处理

**2.renderToStaticMarkup()**

```js
ReactDOMServer.renderToStaticMarkup(element);
```

- 将组件渲染为 html 字符串，`不`会`带`有 `data-react-checksum` 属性

- 如果只是单纯服务端渲染的话可以用该方法，性能比 renderToString 高
  - 因为不需要计算，还能减少直出的内容体积

### 2）性能提升

- 从 `react 16 开始`，服务端渲染 `renderToString` 方法渲染的结果不再有 `data-react-*`属性

- 提供了一个客户端渲染 API - `ReactDOM.hydrate()`

  - 在浏览器端渲染时，该方法会最大限度的保留服务端使用 renderToString()渲染的内容，同时添加事件绑定等交互

  - 提供了可以将组件转换为字截流的 `renderToNodeStream` 方法，性能有提升，可以有效缩短 `TTFB` 时间
  - 采用`流`的形式，可以边读边输出，可以要让页面更快的展现，缩短首屏展现时间

## 9.同构应用流程图

![image](images/frame/16.png)

## 10.TDK

- title 当前页面的`标题`
- description 当前页面的`描述`
- keywords 当前页面的`关键词`

## 11.设计

- 1.数据预取

- 2.数据脱水

- 3.热更新

- 4.路由配置

- 5.路由分割

- 6.CSS 资源

- 7.csr/ssr 双模式
