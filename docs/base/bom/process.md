---
toc: menu
---

# 浏览器进程和线程

- JS 是`单线程`的，JS 是通过`事件队列`(Event Loop)的方式来实现`异步回调`的

## 1.CPU

- 计算机的核心是 CPU，它承担了所有的计算任务

- 它就像`一座工厂`，时刻在运行

- 单个 CPU 一次只能运行一个任务

## 2.进程

- 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）

- 进程就好比`工厂的车间`，它代表 CPU 所能处理的单个任务。 进程之间相互独立，任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。 CPU 使用时间片轮转进度算法来实现同时运行多个进程

- 不同进程之间也可以通信，不过代价较大

## 3.线程

- 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

- 线程就好比`车间里的工人`，一个进程可以包括多个线程，多个线程共享进程资源

## 4.浏览器是多进程的

- 对于计算机来说，每一个应用程序都是一个进程， 而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过子进程来实现的。 对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的

### 1）Chrome 浏览器进程

- 浏览器从关闭到启动，然后新开一个页面需要：**1 个浏览器主进程，1 个 GPU 进程，1 个网络进程，多个渲染进程，和多个插件进程**

  - `浏览器进程`： 负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能
  - `GPU进程`：负责整个浏览器界面的渲染。Chrome 刚开始发布的时候是没有 GPU 进程的，而使用 GPU 的初衷是为了实现 3D CSS 效果，只是后面网页、Chrome 的 UI 界面都用 GPU 来绘制，这使 GPU 成为浏览器普遍的需求，最后 Chrome 在多进程架构上也引入了 GPU 进程
  - `网络进程`：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程
  - `插件进程`：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响
  - `渲染进程`：负责控制显示 tab 标签页内的所有内容，核心任务是将 HTML、CSS、JS 转为用户可以与之交互的网页，排版引擎 Blink 和 JS 引擎 V8 都是运行在该进程中，默认情况下 Chrome 会为每个 Tab 标签页创建一个渲染进程

    - 我们平时看到的浏览器呈现出页面过程中，大部分工作都是在`渲染进程`中完成
    - 也被称为浏览器内核，分类
      - Google Chrome：Chrome 28 开发版本中还在使用 `WebKit`，最新的 `Chrome` 使用 `Blink。`
      - Internet Explorer：`Trident 内核`，`ie 内核`
      - Mozilla Firefox：`Gecko` 内核，`firefox` 内核
      - safari：`Webkit`
      - Opera：最初是 `Presto` 内核，后来是 `Webkit`，现在是 `Blink` 内核

### 2）渲染进程中的线程

- 渲染进程是多线程的

  - `GUI渲染线程`：负责渲染页面，解析 html 和 CSS、构建 DOM 树、CSSOM 树、渲染树、和绘制页面，重绘重排也是在该线程执行
  - `JS引擎线程`：一个 tab 页中只有一个 JS 引擎线程(单线程)，负责解析和执行 JS。它 GUI 渲染进程不能同时执行，只能一个一个来，如果 JS 执行过长就会导致阻塞掉帧
  - `计时器线程`：指 setInterval 和 setTimeout，因为 JS 引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作
  - `异步http请求线程`： XMLHttpRequest 连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待 JS 引擎空闲执行
  - `事件触发线程`：主要用来控制事件循环，比如 JS 执行遇到计时器，AJAX 异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等 JS 引擎处理

## 5.为什么 javascript 是单线程的

- 首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好
- 其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高
- 而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期

## 6.为什么 GUI 渲染线程与 JS 引擎线程互斥

- 这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)，那么渲染线程前后获得的元素就可能不一致了。

- 因此，为了防止渲染出现不可预期的结果，浏览器设定 `GUI 渲染线程`和 `JS 引擎线程`为互斥关系，
  当 `JS 引擎线程`执行时 `GUI 渲染线程`会被挂起，GUI 更新则会被保存在一个队列中等待 `JS 引擎线程`空闲时立即被执行

- 这就是为什么执行死循环，页面会卡住

## 7.浏览器渲染流程

- 构建 DOM 树 -> CSS Parser -> 样式计算 -> 布局阶段 -> 分层 ->绘制 -> 分块 -> 光栅化和合成，渲染是在渲染进程执⾏的，渲染进程分为渲染主线程、光栅线程、合成线程等；从分块阶段开始，分块、光栅化、合成这三步是在⾮渲染主线程执⾏。

### 1）渲染流程

- 1.构建 DOM 树: 渲染进程通过 HTML Parser 将 HTML 字符串转换为浏览器能够读懂的 DOM 树结构，查看：document

- 2.构建 Style Rules: 渲染引擎将 CSS 字符串转化为浏览器可以理解的 styleSheets，查看：document.styleSheets

- 3.样式计算：根据上⾯两步⽣成的 DOM Tree 和 Style Rules，可以计算出 DOM 节点的样式。

- 4.创建布局树：计算出 DOM 节点的样式后，还需要知道 DOM 节点在⻚⾯中显示的位置，这就需要计算元素的布局信息，⽣成⼀颗布局树，其中不包括不显示的 DOM 节点。

- 5.分层：对布局树进⾏分层，并⽣成分层树，具体哪些元素需要分层是由 CSS 决定的，⽐如 `z-index` 等，也可以设置 `will-change` 来通知浏览器此元素需要分层。

- 6.绘制：为每个图层⽣成绘制列表，并将其提交到合成线程。

- 7.分块、光栅化: 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

- 8.合成：把光栅化⽣成的多张位图合成⼀张位图；合成线程发送绘制图块命令 DrawQuad 给浏览器进程。

- 9.显示：浏览器进程根据 DrawQuad 消息⽣成⻚⾯，并显示到显示器上

### 2）相关问题

- 1.HTML Parser 需要等待 HTML 全部加载完再解析？还是边加载边解析？

  - 一边加载一边解析，转换为：document

- 2.JS 如何影响 HTML Parser？

  - script 脚本放在 body 元素中页面内容的后面，避免 js 阻碍 html 解析，减少白屏时间，

    - 内嵌的 js 脚本会执行阻塞 html 解析、网络加载的 js 脚本也会阻塞 html 解析
    - script 标签中的 defer 属性，延迟执行脚本，解析完</html>后执行，执行顺序不变，即第一个 defer 脚本会在第二个 defer 脚本前执行
    - script 标签中的 async 属性，异步执行脚本，文件加载完成后执行，无法保证执行顺序，哪个加载完哪个执行。

- 3.css 如何影响 js 执行？

  - 由于 JS 可以获取和操作样式，因此会等待 JS 语句之前的 CSS Parser 完成后才会执⾏此 JS ⽂件。 结论： CSS Parser -> JS 执⾏ -> HTML Parser。

- 4.css 的渲染？

  - 计算样式的过程不会等待⻚⾯的底部的 Style rules ⽣成完毕， 会先 paint ⼀次⻚⾯，等⻚⾯底部的 CSS 解析完成后，repaint ⼀次，会看到闪烁的情况；因此 CSS ⽂件尽量放在 head 中，尽快下载 CSS ⽂件并解析，然后结合 dom 渲染到⻚⾯中

- 5.性能优化方法：下载 CSS ⽂件并解析、下载 JS ⽂件并执⾏可能会影响到⻚⾯的⾸屏渲染。因此⼀般可采⽤如下策略：

  - css 文件加载尽量放在 head 中，减少 CSS ⽂件体积，对于⼤的 CSS ⽂件，可以通过媒体查询的⽅式加载不同⽤途的 CSS ⽂件， 参考

  - 动画采⽤ css3 动画，或者添加 will-change 属性

  - script 标签放在⻚⾯内容后，或者不需要在 HTML Parser 阶段使⽤的，可以加上 defer 或者 async

  - ⽹络层⾯：DNS prefetch； 采⽤ CDN；开启 HTTP2 等
