---
toc: menu
---

# 尾调用

## 1.调用栈（Call Stack）

### 栈帧

- 是指为一个函数调用单独分配的那部分栈空间

- 当运行的程序从当前函数调用另外一个函数时，就会为下一个函数建立一个新的栈帧，并且进入这个栈帧，这个栈帧称为当前帧。而原来的函数也有一个对应的栈帧，被称为调用帧。每一个栈帧里面都会存入当前函数的局部变量

- 当函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数。并将程序运行权利（帧指针）交给此时栈顶的栈帧。这种后进后出的结构也就是函数的调用栈

- 通过 console.trace()这个方法查看当前函数的调用帧

```js
function add() {
  console.trace();
}
```

## 2.尾调用

- 一个函数执行的最后一步是将另外一个函数调用并返回

```js
// 尾调用
function f(x) {
  return g(x);
}

// 非尾调用，因为 g(x) 的返回值还需要跟 1 进行计算后，f(x)才会返回值
function f(x) {
  return g(x) + 1;
}
```

## 3.尾调用优化

- 如果所有函数的调用都是尾调用，那么调用栈的长度就会小很多，这样需要占用的内存也会大大减少。这就是尾调用优化的含义

## 4.尾递归

### 1）普通递归写法

- 调用栈随着 n 的增加而线性增加，当 n 为一个大数（我测了一下，当 n 为 100 的时候，浏览器窗口就会卡死。。）时，就会爆栈了（栈溢出，stack overflow）。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存

```js
function fib(n) {
  return n < 2 ? n : fib(n - 1) + fib(n - 2);
}

console.log(fib(5)); // 1 1 2 3 5
```

### 2）尾递归写法

- 被尾递归改写之后的调用栈永远都是更新当前的栈帧而已，这样就完全避免了爆栈的危险

```js
function fib(n, current = 0, next = 1) {
  if (n === 1) return next;
  if (n === 0) return 0;
  return fib(n - 1, next, current + next);
}
console.log(fib(5)); // 1 1 2 3 5
```
