---
toc: menu
---

# 内存管理机制

## 1.什么是内存

在 JS 执行过程中，主要有三种内存空间：`代码空间、栈、堆`

- 1.栈内存中的变量一般都是有已知大小或者范围上限的，算作是一种简单储存。而堆内存存储的对象类型数据对于大小这方面，一般是未知的。这也是为什么 Null 作为一个 object 类型的变量却储存在栈内存中的原因

- 2.闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量

- 3.栈内存由于它的特点，所以它的系统效率较高。 堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈

### 1）代码空间

主要是用来存储可执行代码的

### 2）栈内存（stack）

- 栈是一种后进先出的数据结构

- 执行代码时工作的内存空间，主要用于存储各种`基本类型`的变量以及对象和`变量的指针`

- `存储 Boolean、Null、Undefined、Number、变量的指针`

  - 原因：这些类型的值都可以用 32 位的数据来表示

  - 栈内存的一个单元最多可以存储 32 位

- 栈里面的值发生改变时：JavaScript 引擎是直接修改内存中的值

### 3）堆内存（heap）

- 是一颗完全二叉树，通常采用数组来存储完全二叉树

- `存储 Symbol、BigInt、Object、String 类型`

- 特别注意`字符串是保存在堆中的`

  - 原因：字符串的长度肯定是可以超过 32 位的

  - 在 v8 引擎中对值得驻留的字符串内存中相同的字符串只会保存一份，值得驻留的字符串指的是在有些场景下会重复出现的字符串，当两个变量保存相同的字符串时，它们实际上是保存了这个字符串在内存中的地址。这叫作字符串驻留（String Interning）

## 2.生命周期

- 1.内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存

- 2.内存使用：即读写内存，也就是使用变量、函数等

- 3.内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

## 3.垃圾回收机制

### 1）定义

对于 JavaScript 来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个`自动释放内存的过程称为垃圾回收`

- 1.栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收，而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收

- 2.`局部变量`只在函数的执行过程中存在， 当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收

- 3.`全局变量`的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收

### 2）内存引用

在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象

### 3）引用计数垃圾收集

1.`引用计数是最初级的垃圾回收算法`，看一个对象是否有指向它的引用，如果没有其他对象指向它，就说明该对象不再需要了

```js
var o = {
  a: {
    b: 2,
  },
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集

var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1; // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a; // 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = 'yo'; // 最初的对象现在已经是零引用了
// 他可以被垃圾回收了
// 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
```

2.致命的问题：`循环引用`

- 如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露

```js
// 循环引用的例子
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o  这里
  return 'azerty';
}
f();
```

- 在调用函数结束后，对象 o1 和 o2 实际上已离开函数范围，因此不再需要了

- 但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。

### 4）\*\*标记清除算法

标记扫描

标记清除算法将“不再使用的对象”定义为“无法达到的对象”

启动时机：

- 某一个空间没有分块的时候

- 对象太多超过空间容量一定限制的时候

- 空间不能保证新生代中的对象转移到老生代中的时候

标记清除的`流程`：

- 1.从根部(js 的全局对象)出发，遍历堆中所有对象，然后标记存活的对象

- 2.标记完成后，销毁没有被标记的对象

由于垃圾回收阶段，会暂停 JS 脚本执行，等垃圾回收完毕后再恢复 JS 执行，这种行为称为`全停顿`(stop-the-world)，导致页面性能和响应能力下降

### 5）增量标记

由于全停顿的原因，2011 年，V8 从 stop-the-world 标记切换到`增量标记`。使用增量标记算法，GC(垃圾回收) 可以将回收任务分解成很多小任务，穿插在 JS 任务中间执行，这样避免了应用出现卡顿的情况

### 6）并发标记

2018 年，GC 技术又有重大突破，就是`并发标记`。让 GC 扫描和标记对象时，`允许 JS 同时运行`

### 7）标记压缩

清除后会造成堆内存出现内存碎片的情况，当碎片超过一定限制后会启动标记压缩算法，将存活的对象向堆中的一端移动，到所有对象移动完成，就清理掉不需要的内存

## 4.内存泄露

### 1）定义

内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。

### 2）判断内存泄露

在`Chrome浏览器`中，可以这样查看内存占用情况

`开发者工具` => `Performance` => `勾选Memory` => `点左上角Record` => `页面操作后点stop`

然后就会显示这段时间内的内存使用情况了

- 一次查看内存占用情况后，看当前内存占用趋势图，走势呈上升趋势，可以认为存在内存泄露

- 多次查看内存占用情况后截图对比，比较每次内存占用情况，如果呈上升趋势，也可以认为存在内存泄露

### 2）常见内存泄露

- 1.全局变量(全局变量不会被回收)

  ```js
  function foo(arg) {
    bar = 'some text';
  }
  ```

  等同于

  ```js
  function foo(arg) {
    window.bar = 'some text';
  }
  ```

- 2.被忘记的定时器或者回调函数

  ```js
  var someResource = getData();
  setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
      // 处理 node 和 someResource
      node.innerHTML = JSON.stringify(someResource));
    }
  }, 1000);
  ```

- 3.闭包

  ```js
  var theThing = null;
  var replaceThing = function () {
    var originalThing = theThing;
    var unused = function () {
      if (originalThing)
        // 对于 'originalThing'的引用
        console.log('hi');
    };
    theThing = {
      longStr: new Array(1000000).join('*'),
      someMethod: function () {
        console.log('message');
      },
    };
  };
  setInterval(replaceThing, 1000);
  ```

  每次调用 replaceThing 时，theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象。 同时 unused 是一个引用了 originalThing 的闭包。

  闭包之间是共享作用域的，尽管 unused 可能一直没有被调用，但是 someMethod 可能会被调用，就会导致无法对其内存进行回收。 当这段代码被反复执行时，内存会持续增长。

- 4.DOM 引用

```js
var elements = {
  button: document.getElementById('button'),
  image: document.getElementById('image'),
  text: document.getElementById('text'),
};
function doStuff() {
  image.src = 'http://some.url/image';
  button.click();
  console.log(text.innerHTML);
}
function removeButton() {
  document.body.removeChild(document.getElementById('button'));
  // 此时，仍旧存在一个全局的 #button 的引用
  // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```

虽然用 removeChild 移除了 button，但是还在 elements 对象里保存着#button 的引用，也就是，DOM 元素还在内存里面

### 3）如何避免内存泄露

记住一个原则：不用的东西，及时归还

- 减少不必要的全局变量，使用严格模式避免意外创建全局变量

- 在你使用完数据后，及时解除引用（闭包中的变量，dom 引用，定时器清除）

- 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题

## 5.垃圾回收的使用场景优化

### 1）数组 array 优化

将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生

```js
const arr = [1, 2, 3, 4];
console.log('浪里行舟');
arr.length = 0; // 可以直接让数字清空，而且数组类型不变。
// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。
```

### 2）对象尽量复用

对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为 null，尽快被垃圾回收掉

```js
var t = {}; // 每次循环都会创建一个新对象
for (var i = 0; i < 10; i++) {
  // var t = {}; // 每次循环都会创建一个新对象
  t.age = 19;
  t.name = '123';
  t.index = i;
  console.log(t);
}
t = null; // 对象如果已经不用了，那就立即设置为null；等待垃圾回收
```

### 3）在循环中的函数表达式，能复用最好放到循环外面

优化前

```js
// 在循环中最好也别使用函数表达式。
for (var k = 0; k < 10; k++) {
  var t = function (a) {
    // 创建了10次  函数对象。
    console.log(a);
  };
  t(k);
}
```

优化后

```js
// 推荐用法
function t(a) {
  console.log(a);
}
for (var k = 0; k < 10; k++) {
  t(k);
}
t = null;
```
