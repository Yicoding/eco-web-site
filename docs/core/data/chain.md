---
toc: menu
---

# 链表

- 链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的

- 优点：添加和删除元素都不需要挪动多余的元素

## 1.形式

- 一个内容为 1->2->3->4->5 的链表

![iamge](images/core/4.png)

## 2.创造关联

- 在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：

```json
{
  // 数据域
  "val": 1,
  // 指针域，指向下一个结点
  "next": {
    "val": 2,
    "next": "..."
  }
}
```

![iamge](images/core/5.png)

## 3.链表结点的创建

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
const node = new ListNode(1);
node.next = new ListNode(2);
```

## 4.链表元素的添加

![iamge](images/core/6.png)

```js
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3);
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next;
// 把node1的 next 指针指向 node3
node1.next = node3;
```

## 4.链表元素的删除

![iamge](images/core/7.png)

```js
node1.next = node3.next;
```

## 5.链表和数组的辨析

- JS 数组未必是真正的数组

- 真正的数组：存储在连续的内存空间里

### 1）连续内存

```js
const arr = [1, 2, 3, 4];
```

### 2）非连续内存

- 底层使用哈希映射分配内存空间，是由对象链表来实现的

```js
const arr = ['haha', 1, { a: 1 }];
```

## 6.高效的增删操作

- 在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)

## 7.麻烦的访问操作

- 当试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点

- 随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)

```js
// 记录目标结点的位置
const index = 10;
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head;
// 反复遍历到第10个结点为止
for (let i = 0; i < index && node; i++) {
  node = node.next;
}
```

## 8.总结

- 链表的插入/删除效率较高，而访问效率较低
- 数组的访问效率较高，而插入效率较低
