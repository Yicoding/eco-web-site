---
toc: menu
---

# 递归与回溯思想

## 1.全排列-坑位不变

> 从 n 个不同元素中任取 m（m≤n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列

> 当 m=n 时所有的排列情况叫全排列

### 1）题目描述

- 给定一个没有重复数字的序列，返回其所有可能的全排列

- 示例：

  - 输入: [1,2,3]

  - 输出: [
    [1,2,3],
    [1,3,2],
    [2,1,3],
    [2,3,1],
    [3,1,2],
    [3,2,1]
    ]

### 2）思路分析

- 不变的是：坑位的数量

  - 不管怎么调整数字的顺序，它们都只能围着这 3 个坑打转

- 全排列就一共有 3x2x1=6 种可能

![image](images/core/40.png)

### 3）编码实现

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const permute = function (nums) {
  // 缓存数组的长度
  const len = nums.length;
  // curr 变量用来记录当前的排列内容
  const curr = [];
  // res 用来记录所有的排列顺序
  const res = [];
  // visited 用来避免重复使用同一个数字
  const visited = {};
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs(nth) {
    // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回
    if (nth === len) {
      // 此时前 len 个坑位已经填满，将对应的排列记录下来
      res.push(curr.slice());
      return;
    }
    // 检查手里剩下的数字有哪些
    for (let i = 0; i < len; i++) {
      // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
      if (!visited[nums[i]]) {
        // 给 nums[i] 打个“已用过”的标
        visited[nums[i]] = 1;
        // 将nums[i]推入当前排列
        curr.push(nums[i]);
        // 基于这个排列继续往下一个坑走去
        dfs(nth + 1);
        // nums[i]让出当前坑位
        curr.pop();
        // 下掉“已用过”标识
        visited[nums[i]] = 0;
      }
    }
  }
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0);
  return res;
};
```

### 4）编码分析

- `Map 结构 visited 的使用`：填坑时，每用到一个数字，都要给这个数字打上“已用过”的标——避免它被使用第二次；数字让出坑位时，对应的排列和 visited 状态也需要被及时地更新掉

- 当走到递归边界时，一个完整的排列也到手了。将这个完整排列推入结果数组时，用了 res.push(curr.slice()) 而不是简单的 res.push(curr) 。为什么这样做？因为全局只有一个唯一的 curr ， curr 的值会随着 dfs 的进行而不断被更新。 slice 方法的作用是帮助我们拷贝出一个不影响 curr 正本的副本，以防直接修改到 curr 的引用

## 2.组合问题：变化的“坑位”

### 1）题目描述

- 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）

- 说明：解集不能包含重复的子集

- 示例

  - 输入: nums = [1,2,3]

  - 输出：[
    [3],
    [1],
    [2],
    [1,2,3],
    [1,3],
    [2,3],
    [1,2],
    []
    ]

### 2）思路分析

- 从 root 出发，每一个数字对应树的一层，存在或不存在对应树的两个分叉。从第一层到第三层，得到的所有完整路径，就是 3 个数的所有可能的组合形式

![image](images/core/41.png)

```js
root                                            []
数字1——第一层                     1                                   []
数字2——第二层            [1,2]            [1]                   [2]         []
数字3———第三层    [1,2,3]     [1,2]  [1,3]   [1]           [2,3]   [2]   [3]  []

```

- 分析这个过程中的递归式与递归边界：

  - `递归式`：检查手里剩下的数字有哪些（和上一道题的递归式是一样的，因为两道题都强调了数字不能重复使用），选取其中一个填进当前的坑里、或者干脆把这个坑空出来（这里就体现出了和上一道题的区别，这道题强调的是存在性而非顺序）

  - `递归边界`：组合里数字个数的最大值。拿示例来说，只给了 3 个数，因此组合里数字最多也只有 3 个，超过 3 个则视为触碰递归边界

### 3）编码实现

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const subsets = function (nums) {
  // 初始化结果数组
  const res = [];
  // 缓存数组长度
  const len = nums.length;
  // 初始化组合数组
  const subset = [];
  // 进入 dfs
  dfs(0);

  // 定义 dfs 函数，入参是 nums 中的数字索引
  function dfs(index) {
    // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
    res.push(subset.slice());
    // 从当前数字的索引开始，遍历 nums
    for (let i = index; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(nums[i]);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

### 4）编码分析

- `递归式的变化`：在上一道题中，检查一个数字是否可用的依据是它是否已被纳入当前排列（ visited 值是否为 1），而这道题中，并不存在一个类似 visited 一样的标记对象。取而代之的，是每次直接以 index 作为了索引起点。这是因为，在排列场景下，一个元素可能出现在任何坑位里；而在组合场景下，坑位的选择逻辑发生了变化，坑位和元素是一一对应的。因此讨论完一个坑位的取舍后，一个元素的取舍也相应地讨论完毕了，直接跳过这个元素的索引往下走即可

- `递归边界的变化`：这道题中，并没有显式的 return 语句来标示递归边界的存在。这个边界的判定被 for 语句偷偷地做掉了： for 语句会遍历所有的数字，当数字遍历完全时，也就意味着递归走到了尽头

## 3.限定组合问题：及时回溯(剪枝)

- `剪枝`：在深度优先搜索中，有时会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”

### 1）题目描述

- 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合

- 示例:

  - 输入: n = 4, k = 2

  - 输出:
    [
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
    ]

### 2）思路分析

- 递归式：普通组合问题，每到一个新的坑位处，都需要对组合结果数组进行更新；这道题中，当且仅当组合内数字个数为 k 个时，才会对组合结果数组进行更新

- 递归边界：只要组合内数字个数达到了 k 个，就不再继续当前的路径往下遍历，而是直接返回

- 只有双向箭头所指的结点组合被认为是有效结果，其它结点都被丢弃了。在寻找这三对结点组合的过程中，一旦找到一对，就停止继续往深处搜索，这就意味着一些结点压根没有机会被遍历到

![image](images/core/42.png)

### 3）编码实现

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
const combine = function (n, k) {
  // 初始化结果数组
  const res = [];
  // 初始化组合数组
  const subset = [];
  // 进入 dfs，起始数字是1
  dfs(1);

  // 定义 dfs 函数，入参是当前遍历到的数字
  function dfs(index) {
    if (subset.length === k) {
      res.push(subset.slice());
      return;
    }
    // 从当前数字的值开始，遍历 index-n 之间的所有数字
    for (let i = index; i <= n; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(i);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

### 4）编码分析

- 这道题中虽然没有直接给出一个 `nums` 数组，而是直接约定了数字的范围为 `1-n` ，但其本质仍然是一个数字集合，像上面这样稍微调整下取值方式即可

## 4.回溯算法

### 1）定义

> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径

- 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”

### 2）回溯算法的基本思想

- 从一条路往前走，能进则进，不能进则退回来，换一条路再试

- 可以理解为是在强调 DFS 过程中“退一步重新选择”这个动作

- DFS 算法其实就是回溯思想的体现

- 涉及剪枝操作的递归，我们一般称之为回溯

## 5.递归与回溯-解题思路总结

### 1）什么时候用

- 题目中`暗示`了`一个或多个解`，并且要求我们`详尽`地`列举`出每一个解的内容时，一定要想到 DFS、想到递归回溯

- 题目经分析后，`可以转化为树形逻辑模型求解`

### 2）为什么这样用

- 递归与回溯的过程，本身就是穷举的过程

- 题目中要求列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的

### 3）怎么用

- `一个模型`——树形逻辑模型：

  - 树形逻辑模型的构建，关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容

- `两个要点`——递归式和递归边界：

  - 递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界

### 4）解题模版

```js
function xxx(入参) {
  前期的变量定义、缓存等准备工作

  // 定义路径栈
  const path = []

  // 进入 dfs
  dfs(起点)

  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return
    }

    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```

### 5）需要注意的点

- dfs 递归有一个很重要的点，就是得及时清除保存数组的中的临时值，并且保证数组的引用正确

- 递归（继续前进） 回溯（撞到南墙）

- 不问解的内容，只问解的个数。这类问题往往不用 DFS 来解，而是用动态规划
