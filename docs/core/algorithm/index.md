---
toc: menu
---

![image](images/summary/8.png)

# 时间复杂度与空间复杂度

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述

## 1.时间复杂度

> T(n) = O( f(n) )

- n 是输入数据的大小或者输入数据的数量
- T(n) 表示一段代码的总执行时间
- f(n) 表示一段代码的总执行次数
- O 表示代码的执行时间 T(n) 和 执行次数 f(n) 成正比

### 1）时间复杂度计算

- `O(1)`：**如果只是常数直接估算为 1**，O(3) 的时间复杂度就是 O(1)

  - 一般情况下，只要算法里没有循环和递归，就算有上万行代码，时间复杂度也是 O(1)
  - 它的执行次数不会随着任何一个变量的增大而变长

  ```js
  function foo() {
    let n = 1;
    let b = n * 100;
    if (b === 100) {
      console.log('开始打印');
    }
    console.log('打印了1次');
    console.log('打印了2次');
    // ......
    console.log('打印了10000次');
  }
  ```

- `O(n)`：**去掉系数**， O(3n+4) 的时间复杂度为 O(n)

  - 系数和常数对于总执行次数的几乎没有影响
  - 只有一层循环或者递归等，时间复杂度就是 O(n)

  ```js
  function foo1(n) {
    for (let i = 0; i < n; i++) {
      console.log('打印了1次');
    }
  }
  function foo2(n) {
    while (--n > 0) {
      console.log('打印了1次');
    }
  }
  function foo3(n) {
    console.log('打印了1次');
    --n > 0 && foo3(n);
  }
  ```

- `O(n^x)`：**如果是多项式，只需要保留 n 的最高次项**，O( 666n³ + 666n² + n )的时间复杂度为 O(n^3)

  - 比如嵌套循环

  ```js
  function foo1(n) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        console.log('打印了1次');
      }
    }
  }
  ```

  - 如果是多项式，取最高次项，所以这个时间复杂度也是 O(n²)

  ```js
  function foo2(n) {
    for (let k = 0; k < n; k++) {
      console.log('打印了1次');
    }
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        console.log('打印了1次');
      }
    }
  }

  //或者下面这样，以运行时间最长的，作为时间复杂度的依据，所以下面的时间复杂度就是 O(n²)
  function foo3(n) {
    if (n > 100) {
      for (let k = 0; k < n; k++) {
        console.log('打印了1次');
      }
    } else {
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          console.log('打印了1次');
        }
      }
    }
  }
  ```

- `O(logn)`：循环次数的影响主要来源于 n/2 ，这个时间复杂度就是 O(logn)

  ```js
  function foo2(n) {
    for (let i = 0; i < n; i *= 2) {
      console.log(`当前i为${i}`);
    }
  }
  foo2(16);
  ```

### 2）算法时间复杂的排行

- `O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)`

### 3）时间复杂度简化

`O(2*n^2 + 10*n + 1000)`

去掉常数 =>

`O(2*n^2 + 10*n)`

去掉系数 =>

`O(n^2 + n)`

只保留最高项 =>

`O(n^2)`

### 4）题目描述：找出 n 个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

**1.枚举遍历的解法**

- 枚举遍历的解法，时间复杂度是 O(n^2)
- 除了 n^2 次的遍历次数外， 字符串比较依然要消耗 m 次操作（m 也就是字母串的长度），所以时间复杂度是 `O(m*n*n)`

**2.其他思路**

- 先排对 n 个字符串按字典序来排序，排序后 n 个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍 n 个字符串，这样就找到两个相同的字符串了

  - 快速排序时间复杂度 为`O(nlogn)`，依然要考虑字符串的长度是 m，那么快速排序每次的比较都要有 m 次的字符比较的操作，就是`O(m*n*logn)`
  - 之后还要遍历一遍这 n 个字符串找出两个相同的字符串，遍历的时候依然要比较字符串，所以总共的时间复杂度是 `O(m*n*logn + n*m)`
  - 对`O(m*n*logn + n*m)` 进行简化操作，把`m*n`提取出来变成`O(m*n*(logn + 1))`
  - 在省略常数项最后的时间复杂度是 `O(m*n*logn)`

- `O(m*n*logn) 要优于O(m*n*n)`
  - 先把字符串集合排序在遍历一遍找到两个相同字符串的方式要比直接暴力枚举的方式更快

## 2.空间复杂度

- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度

- 常用的空间复杂度有 `O(1)、O(n)、O(n²)`

### 1）O(1)

- 只要不会因为算法里的执行，导致额外的空间增长，就算是一万行，空间复杂度也是 O(1)，时间复杂度也是 O(1)

  ```js
  function foo(){
    let n = 1
    let b = n * 100
    if(b === 100){
        console.log("开始打印")
    }
    console.log("打印了1次")
    console.log("打印了2次")
    ......
    console.log("打印了10000次")
  }
  ```

### 2）O(n)

- n 的数值越大，算法需要分配的空间就需要越多，来存储数组里的值，所以它的空间复杂度就是 O(n)，时间复杂度也是 O(n)

  ```js
  function foo(n) {
    let arr = [];
    for (let i = 1; i < n; i++) {
      arr[i] = i;
    }
  }
  ```

### 3）O(n²)

- O(n²) 这种空间复杂度一般出现在比如二维数组，或是矩阵的情况下

- 遍历生成类似这样格式的

  ```js
  let arr = [
    [1, 2, 3, 4, 5],
    [1, 2, 3, 4, 5],
    [1, 2, 3, 4, 5],
  ];
  ```
