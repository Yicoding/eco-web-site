---
toc: menu
---

# 进阶排序算法

## 1.“分治”思想

- 分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解：

  - 1.分解子问题

  - 2.求解每个子问题

  - 3.合并子问题的解，得出大问题的解

## 2.归并排序

### 1）思路分析

- `分解子问题`：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止

- `求解每个子问题`：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）

- `合并子问题的解，得出大问题的解`：当数组被合并至原有的规模时，就得到了一个完全排序的数组

### 2）编码思路

- 1.归并排序中的两个主要动作：

  - 分割

  - 合并

- 2.分割是将大数组反复分解为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。整个过程符合两个特征：

  - 重复（令人想到递归或迭代）

  - 有去有回（令人想到回溯，进而明确递归这条路）

- 3.涉及到两个有序数组的合并：使用双指针法

### 3）编码实现

```js
function mergeSort(arr) {
  const len = arr.length;
  // 处理边界情况
  if (len <= 1) {
    return arr;
  }
  // 计算分割点
  const mid = Math.floor(len / 2);
  // 递归分割左子数组，然后合并为有序数组
  const leftArr = mergeSort(arr.slice(0, mid));
  // 递归分割右子数组，然后合并为有序数组
  const rightArr = mergeSort(arr.slice(mid, len));
  // 合并左右两个有序数组
  arr = mergeArr(leftArr, rightArr);
  // 返回合并后的结果
  return arr;
}

function mergeArr(arr1, arr2) {
  // 初始化两个指针，分别指向 arr1 和 arr2
  let i = 0,
    j = 0;
  // 初始化结果数组
  const res = [];
  // 缓存arr1的长度
  const len1 = arr1.length;
  // 缓存arr2的长度
  const len2 = arr2.length;
  // 合并两个子数组
  while (i < len1 && j < len2) {
    if (arr1[i] < arr2[j]) {
      res.push(arr1[i]);
      i++;
    } else {
      res.push(arr2[j]);
      j++;
    }
  }
  // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
  if (i < len1) {
    return res.concat(arr1.slice(i));
  } else {
    return res.concat(arr2.slice(j));
  }
}
```

### 4）归并排序的时间复杂度分析

- 归并排序的时间复杂度的分析，同样是基于分治法

- 1.分割：

  - 把每一次切分+归并看做是一轮。对于规模为 n 的数组来说，需要切分 log(n) 次，因此就有 log(n) 轮

  - 每一轮中，切分动作都是小事情，只需要固定的几步：

    ```js
    // 计算分割点
    const mid = Math.floor(len / 2);
    // 递归分割左子数组，然后合并为有序数组
    const leftArr = mergeSort(arr.slice(0, mid));
    // 递归分割右子数组，然后合并为有序数组
    const rightArr = mergeSort(arr.slice(mid, len));
    ```

  - 因此单次切分对应的是常数级别的时间复杂度 `O(1)`

- 2.合并：

  - 单次合并的时间复杂度为 `O(n)`。O(n) 和 O(1) 完全不在一个复杂度量级上，因此本着“抓主要矛盾”的原则，可以认为：`决定归并排序时间复杂度的操作就是合并操作`

  - log(n) 轮对应 log(n) 次合并操作，因此归并排序的时间复杂度就是 `O(nlog(n))`

## 3.快速排序

- 快速排序在基本思想上和归并排序是一致的，坚持“分而治之”的原则

- 和归并排序的区别：

  - 快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序

### 1）思路分析

- `快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组`

### 2）过程

- 1.选取一个基准值：比如选取数组中间的值

```js
[5, 1, 3, 6, 2, 0, 7]
 ↑       基准      ↑
```

- 2.左右指针分别指向数组的两端：

  - 先移动左指针，直到找到一个不小于基准值的值为止

  - 然后再移动右指针，直到找到一个不大于基准值的值为止

  - 左指针最终指向了基准值：

    - 此时由于 6===6，左指针停止移动

      ```js
      [5, 1, 3, 6, 2, 0, 7]
              基准      ↑
                ↑
      ```

- 3.开始看右指针：

  - 右指针指向 7，7>6，故左移右指针

    ```js
    [5, 1, 3, 6, 2, 0, 7]
            基准     ↑
              ↑
    ```

  - 0 比 6 小，停下来，交换 6 和 0，同时两个指针共同向中间走一步：

    ```js
    [5, 1, 3, 0, 2, 6, 7]
                 ↑ 基准
                 ↑
    ```

  - 此时 2 比 6 小，故右指针不动，左指针继续前进：

  - 此时右指针所指的值不大于 6，左指针所指的值不小于 6，故两个指针都不再移动

    ```js
    [5, 1, 3, 0, 2, 6, 7]
                 ↑  基准
               right↑
                  left
    ```

- 4.以左指针为轴心，划分出一左一右、一小一大两个子数组：

```js
[5, 1, 3, 0, 2][(6, 7)];
```

### 3）编码实现

```js
// 快速排序入口
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 定义递归边界，若数组只有一个元素，则没有排序必要
  if (arr.length > 1) {
    // lineIndex表示下一次划分左右子数组的索引位
    const lineIndex = partition(arr, left, right);
    // 如果左边子数组的长度不小于1，则递归快排这个子数组
    if (left < lineIndex - 1) {
      // 左子数组以 lineIndex-1 为右边界
      quickSort(arr, left, lineIndex - 1);
    }
    // 如果右边子数组的长度不小于1，则递归快排这个子数组
    if (lineIndex < right) {
      // 右子数组以 lineIndex 为左边界
      quickSort(arr, lineIndex, right);
    }
  }
  return arr;
}
// 以基准值为轴心，划分左右子数组的过程
function partition(arr, left, right) {
  // 基准值默认取中间位置的元素
  let pivotValue = arr[Math.floor(left + (right - left) / 2)];
  // 初始化左右指针
  let i = left;
  let j = right;
  // 当左右指针不越界时，循环执行以下逻辑
  while (i <= j) {
    // 左指针所指元素若小于基准值，则右移左指针
    while (arr[i] < pivotValue) {
      i++;
    }
    // 右指针所指元素大于基准值，则左移右指针
    while (arr[j] > pivotValue) {
      j--;
    }

    // 若i<=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序
    if (i <= j) {
      swap(arr, i, j);
      i++;
      j--;
    }
  }
  // 返回左指针索引作为下一次划分左右子数组的依据
  return i;
}

// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}
```

### 4）快速排序的时间复杂度分析

- 快速排序的时间复杂度的好坏，是由基准值来决定的：

  - `最好`时间复杂度：它对应的是这种情况——我们每次选择基准值，都刚好是当前子数组的中间数。这时，可以确保每一次分割都能将数组分为两半，进而只需要递归 log(n) 次。这时，快速排序的时间复杂度分析思路和归并排序相似，最后结果也是 `O(nlog(n))`

  - `最坏`时间复杂度：每次划分取到的都是当前数组中的最大值/最小值。大家可以尝试把这种情况代入快排的思路中，你会发现此时快排已经退化为了冒泡排序，对应的时间复杂度是 `O(n^2)`

  - `平均`时间复杂度： `O(nlog(n))`
