---
toc: menu
---

# 动态规划通用套路

- 动态规划是一种思想：非常好用的套路

## 1.爬楼梯

### 1）题目描述

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶

- 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

- 注意：给定 n 是一个正整数

- 示例 1：

  - 输入： 2

  - 输出： 2

  - 解释： 有两种方法可以爬到楼顶

- 示例 2：

  - 输入： 3
  - 输出： 3
  - 解释： 有三种方法可以爬到楼顶

> 1、1 阶 + 1 阶 + 1 阶
>
> 2、1 阶 + 2 阶
>
> 3、2 阶 + 1 阶

### 2）思路分析

- 两个关键的特征：

  - 1.要求你给出达成某个目的的解法个数

  - 2.不要求你给出每一种解法对应的具体路径

### 3）递归思想分析问题

- 首先要想到的思维工具就是“倒着分析问题”：

  - 1.定位到问题的终点

  - 2.站在终点这个视角，思考后退的可能性

- “问题的终点”指的就是走到第 n 阶楼梯这个目标对应的路径数，记为 f(n)：

  - 把抵达第 n-1 阶楼梯对应的路径数记为 f(n-1)

  - 把抵达第 n-2 阶楼梯对应的路径数记为 f(n-2)

  ```js
  // f(n)拆分
  f(n) = f(n-1) + f(n-2)

  // f(n-1)拆分
  f(n-1) = f(n-2) + f(n-3)

  // f(n-2)拆分
  f(n-2) = f(n-3) + f(n-4)

  // 直到拆分到
  f(1) = 1
  f(2) = 2
  ```

- 编码实现：

  ```js
  /**
   * @param {number} n
   * @return {number}
   */
  const climbStairs = function (n) {
    // 处理递归边界
    if (n === 1) {
      return 1;
    }
    if (n === 2) {
      return 2;
    }
    // 递归计算
    return climbStairs(n - 1) + climbStairs(n - 2);
  };
  ```

- 递归解法的问题：会产生大量的重复计算问题(图上标红的均为发生过重复计算的结点）)

![image](images/core/48.png)

### 4）记忆化搜索来提效

- 解决思路：用空间换时间

  - 想办法记住之前已经求解过的结果

- 定义一个数组：每计算出一个 f(n) 的值，都把它塞进 f 数组里。下次要用到这个值的时候，直接取出来

  ```js
  /**
   * @param {number} n
   * @return {number}
   */
  // 定义记忆数组 f
  const f = [];
  const climbStairs = function (n) {
    if (n == 1) {
      return 1;
    }
    if (n == 2) {
      return 2;
    }
    // 若f[n]不存在，则进行计算
    if (f[n] === undefined) f[n] = climbStairs(n - 1) + climbStairs(n - 2);
    // 若f[n]已经求解过，直接返回
    return f[n];
  };
  ```

### 5）记忆化搜索转化为动态规划

**1.记忆化搜索与动态规划的区别**

- 记忆化搜索：可以理解为优化过后的递归，递归往往可以基于树形思维模型来做

  - 基于树形思维模型来解题时，实际上是站在了一个比较大的未知数量级（也就是最终的那个 n），来不断进行拆分，最终拆回较小的已知数量级（f(1)、f(2)）

  - 这个过程是一个明显的自顶向下的过程

- 动态规划：相反，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值：

  - 以 f(1) 和 f(2) 为起点，不断求和，循环递增 n 的值，就能够求出 f(n)了

    ```js
    /**
     * @param {number} n
     * @return {number}
     */
    const climbStairs = function (n) {
      // 初始化状态数组
      const f = [];
      // 初始化已知值
      f[1] = 1;
      f[2] = 2;
      // 动态更新每一层楼梯对应的结果
      for (let i = 3; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 2];
      }
      // 返回目标值
      return f[n];
    };
    ```

### 6）动态规划解题思路

- 分治问题的核心思想是：把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解

- 动态规划的思想和“分治”有点相似。不同之处在于，“分治”思想中，各个子问题之间是独立的：比如说归并排序中，子数组之间的排序并不互相影响。而动态规划划分出的子问题，往往是相互依赖、相互影响的

- 使用动态规划解题的特征：

  - 1.最优子结构：

    - 它指的是问题的最优解包含着子问题的最优解——不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策：f(n)和 f(n-1)、f(n-2)之间的关系

  - 2.重叠子问题：

    - 指的是在递归的过程中，出现了反复计算的情况

### 7）动态规划问题的分析技巧

- 1.通过递归与回溯，分析出树形思维模型和递归边界条件

- 2.基于树形思维模型，结合记忆化搜索

- 3.递归转迭代

- 分析路径：

  - 1.递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系
  - 2.结合记忆化搜索，明确状态转移方程
  - 3.递归代码转化为迭代表达

## 2.“最值”型问题

### 1） 题目描述

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1

- 示例 1：

  - 输入: coins = [1, 2, 5], amount = 11

  - 输出: 3

  - 解释: 11 = 5 + 5 + 1

- 示例 2：

  - 输入: coins = [2], amount = 3

  - 输出: -1

- 提示：最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划

### 2）方程式

```js
f(amount) = Math.min(f(amount-c1)+1, f(amount-c2)+1, f(amount-c3)+1,...,f(amount-cn)+1)
f[0] = 0
```

### 3）编码实现

```js
const coinChange = function (coins, amount) {
  // 用于保存每个目标总额对应的最小硬币个数
  const f = [];
  // 提前定义已知情况
  f[0] = 0;
  // 遍历 [1, amount] 这个区间的硬币总额
  for (let i = 1; i <= amount; i++) {
    // 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
    f[i] = Infinity;
    // 循环遍历每个可用硬币的面额
    for (let j = 0; j < coins.length; j++) {
      // 若硬币面额小于目标总额，则问题成立
      if (i - coins[j] >= 0) {
        // 状态转移方程
        f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      }
    }
  }
  // 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
  if (f[amount] === Infinity) {
    return -1;
  }
  // 若有解，直接返回解的内容
  return f[amount];
};
```
