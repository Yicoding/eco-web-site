---
toc: menu
---

# 动态规划重点解题模型

## 1.背包模型

### 1）定义

> 有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？

- 注意：每种物品都只有 1 件

### 2）思路分析

- 暴力枚举法：考虑到每一种物品都面临“放”和“不放”两种选择，因此 n 个物品就对应 2^n 种情况，进而会带来高达 O(2^n)的时间复杂度

- “倒推”法明确状态间关系：

  - 假设背包已满，容量已经达到了 c。站在 c 这个容量终点往后退，考虑从中取出一样物品，那么可能被取出的物品就有 i 种可能性。我们现在尝试表达“取出一件”这个动作对应的变化，我用 f(i, c) 来表示前 i 件物品恰好装入容量为 c 的背包中所能获得的最大价值。现在假设我试图取出的物品是 i，那么只有两种可能：

    - 第 i 件物品在背包里
    - 第 i 件物品不在背包里

### 3）编码实现

```js
// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组
function knapsack(n, c, w, value) {
  // dp是动态规划的状态保存数组
  const dp = new Array(c + 1).fill(0);
  // res 用来记录所有组合方案中的最大值
  let res = -Infinity;
  for (let i = 1; i <= n; i++) {
    for (let v = c; v >= w[i]; v--) {
      // 写出状态转移方程
      dp[v] = Math.max(dp[v], dp[v - w[i]] + value[i]);
      // 即时更新最大值
      if (dp[v] > res) {
        res = dp[v];
      }
    }
  }
  return res;
}
```

## 2.最长上升子序列模型

### 1）题目描述

> 题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度

- 示例:

  - 输入: [10,9,2,5,3,7,101,18]

  - 输出: 4

  - 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4

- 说明:

  - 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n^2)

  - 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

### 2）思路分析

- 子序列：指的是在原有序列的基础上，删除 0 个或者多个数，其他数的顺序保持不变得到的结果

  ```bash
  [10,9,2,5,3,7,101,18]

  # 随便拿掉0个数或多个数,但是不打乱这个序列的顺序
  [9,2,5,3,7,101]
  ```

- 上升：指的是排在后面的元素总是要大于排在前面的元素

### 3）编码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 入参是一个数字序列
const lengthOfLIS = function (nums) {
  // 缓存序列的长度
  const len = nums.length;
  // 处理边界条件
  if (!len) {
    return 0;
  }
  // 初始化数组里面每一个索引位的状态值
  const dp = new Array(len).fill(1);
  // 初始化最大上升子序列的长度为1
  let maxLen = 1;
  // 从第2个元素开始，遍历整个数组
  for (let i = 1; i < len; i++) {
    // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列
    for (let j = 0; j < i; j++) {
      // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    // 及时更新上升子序列长度的最大值
    if (dp[i] > maxLen) {
      maxLen = dp[i];
    }
  }
  // 遍历完毕，最后到手的就是最大上升子序列的长度
  return maxLen;
};
```
