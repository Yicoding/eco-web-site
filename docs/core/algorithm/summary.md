---
toc: menu
---

# 算法总结

## 1.做题思路总结

| 序号 | 思路                                                                             | 对应算法                       |
| :--- | :------------------------------------------------------------------------------- | :----------------------------- |
| 1    | 当发现代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环     | `空间换时间`                   |
| 2    | 几乎所有的求和问题，都可以转化为求差问题                                         | `空间换时间`                   |
| 3    | 数组有序时，在涉及求和、比大小类的数组题目里时                                   | `双指针法`                     |
| 4    | 当遇见“有序”和“数组”时，需要联想到对撞指针                                       | `对撞指针`                     |
| 5    | 对回文字符串的对称特性利用得是否彻底，是判断解决回文类问题的解法是否“高效”的依据 | `对称特性`                     |
| 6    | 处理链表的本质，是处理链表结点之间的指针关系                                     | `链表`                         |
| 7    | 无法定位到第一个结点的前驱结点，用一个 dummy 结点来解决这个问题                  | `dummy结点`                    |
| 8    | 涉及到反复的遍历                                                                 | `快慢指针`                     |
| 9    | 涉及相对复杂的链表操作，比如反转、指定位置的删除等                               | `多指针`                       |
| 10   | 题目中若涉及括号问题，则很有可能和栈相关                                         | `栈`                           |
| 11   | 避免重复操作的秘诀就是及时地将不必要的数据出栈，避免它对我们后续的遍历产生干扰   | `栈结构可以帮我们避免重复操作` |
| 12   | 双端队列就是允许在队列的两端进行插入和删除的队列                                 | `双端队列`                     |
| 13   | 使用双端队列法，核心的思路是维护一个有效的递减队列                               | `双端队列`                     |
| 14   | 递归的本质是栈                                                                   | -                              |
| 15   | 出现重复、穷举的情况，需要想到递归 DFS（排除掉类似数组遍历这种简单粗暴的重复）   | `递归DFS`                      |
| 16   | 不问解的内容，只问解的个数。这类问题往往不用 DFS 来解，而是用动态规划            | `动态规划`                     |
| 17   | 最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划                 | `动态规划`                     |

## 2.如何总结出一套解题模板

- 分三步进行总结：

  - 什么时候用？（明确场景）

  - 为什么这样用？（提供依据）

  - 怎么用？（细化步骤）

## 3.深度优先遍历

- 递归解决（容易爆栈）

- 利用堆栈

  - 思路：

    - 1.声明两个数组，缓存数组 arr 和最终的结果数组 result

    - 2.while 循环判断 arr 数组长度是否存在

    - 3.通过 pop 取出数组 arr 最上面的选项 top

    - 4.分情况判断 top 是否满足条件，满足直接 result.push 当前选项

    - 5.不满足 push 条件再单独处理：因为栈遵循后入先出规则，所以看兄弟节点之间的选项顺序是否需要翻转（reverse）

    - 6.处理完成后，将选项 push 到 arr 中继续下次循环的处理

## 4.广度优先遍历

- 利用队列

- 思路：

  - 1.声明两个数组，缓存数组 arr 和最终的结果数组 result

  - 2.while 循环判断 arr 数组长度是否存在

  - 3.通过 shift 取出数组 arr 最前面的选项 top

  - 4.分情况判断 top 是否满足条件，满足直接 result.push 当前选项

  - 5.不满足 push 条件再单独处理

  - 6.处理完成后，将选项 push 到 arr 中继续下次循环的处理
